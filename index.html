/****************************************************
 * TRADING EQUITY CURVE SIMULATOR – FULL JAVASCRIPT
 ****************************************************/

const NUM_PATHS = 80; // number of Monte Carlo equity paths
let equityChart;

// Utility: random float
function rand() {
  return Math.random();
}

// Utility: calculate max drawdown
function calculateMaxDrawdown(arr) {
  let peak = arr[0];
  let maxDD = 0;

  for (let v of arr) {
    if (v > peak) peak = v;
    let dd = (peak - v) / peak;
    if (dd > maxDD) maxDD = dd;
  }
  return maxDD * 100;
}

// Utility: longest win/loss streaks
function calculateStreaks(results) {
  let maxWin = 0, maxLoss = 0;
  let curWin = 0, curLoss = 0;

  for (let r of results) {
    if (r > 0) {
      curWin++;  
      maxWin = Math.max(maxWin, curWin);
      curLoss = 0;
    } else {
      curLoss++;
      maxLoss = Math.max(maxLoss, curLoss);
      curWin = 0;
    }
  }

  return { maxWin, maxLoss };
}

// RUN THE SIMULATION
function runSimulation() {
  const winRate = parseFloat(document.getElementById("winRate").value) / 100;
  const rr = parseFloat(document.getElementById("rr").value);
  const riskPct = parseFloat(document.getElementById("riskPct").value) / 100;
  const numTrades = parseInt(document.getElementById("numTrades").value);
  const initialCapital = parseFloat(document.getElementById("initialCapital").value);

  if (isNaN(winRate) || isNaN(rr) || isNaN(riskPct) || isNaN(numTrades) || isNaN(initialCapital)) {
    alert("Please enter valid numbers.");
    return;
  }

  const allPaths = [];

  for (let p = 0; p < NUM_PATHS; p++) {
    let balance = initialCapital;
    let curve = [];
    let tradeResults = [];

    for (let i = 0; i < numTrades; i++) {
      const riskAmount = balance * riskPct;

      if (rand() < winRate) {
        balance += riskAmount * rr;
        tradeResults.push(riskAmount * rr);
      } else {
        balance -= riskAmount;
        tradeResults.push(-riskAmount);
      }

      curve.push(balance);
    }

    allPaths.push({
      final: balance,
      curve,
      maxDD: calculateMaxDrawdown(curve),
      streaks: calculateStreaks(tradeResults),
      tradeResults
    });
  }

  allPaths.sort((a, b) => a.final - b.final);

  const worst = allPaths[0];
  const median = allPaths[Math.floor(NUM_PATHS / 2)];
  const best = allPaths[NUM_PATHS - 1];

  updateResults({ best, median, worst, initialCapital });
  renderChart(allPaths, { best, median, worst });
  renderProbability(allPaths, initialCapital);
}

// UPDATE RESULTS SECTION
function updateResults({ best, median, worst, initialCapital }) {
  const container = document.getElementById("resultsGrid");
  container.innerHTML = "";

  function card(title, data) {
    return `
      <div class="stat-card">
        <div class="stat-label">${title}</div>
        <div class="stat-value">${data}</div>
      </div>
    `;
  }

  function scenarioBlock(name, obj) {
    const totalReturn = ((obj.final / initialCapital - 1) * 100).toFixed(2) + "%";
    const maxDD = obj.maxDD.toFixed(2) + "%";
    const streaks = `${obj.streaks.maxWin}W / ${obj.streaks.maxLoss}L`;

    return `
      <div class="stat-card">
        <div class="stat-label">${name}</div>
        <div class="stat-value">${totalReturn}</div>
        <div class="stat-note">Max DD: ${maxDD}</div>
        <div class="stat-note">Streaks: ${streaks}</div>
      </div>
    `;
  }

  container.innerHTML =
    scenarioBlock("Best", best) +
    scenarioBlock("Most Probable", median) +
    scenarioBlock("Worst", worst);
}

// RENDER CHART
function renderChart(allPaths, { best, median, worst }) {
  const ctx = document.getElementById("equityChart").getContext("2d");

  if (equityChart) equityChart.destroy();

  equityChart = new Chart(ctx, {
    type: "line",
    data: {
      labels: allPaths[0].curve.map((_, i) => i + 1),
      datasets: [
        ...allPaths.map((p) => ({
          data: p.curve,
          borderColor: "rgba(255,255,255,0.12)",
          borderWidth: 1,
          fill: false,
          pointRadius: 0
        })),
        {
          data: best.curve,
          borderColor: "#40D48B",
          borderWidth: 3,
          pointRadius: 0
        },
        {
          data: median.curve,
          borderColor: "#2EC7FF",
          borderWidth: 3,
          pointRadius: 0
        },
        {
          data: worst.curve,
          borderColor: "#FF7070",
          borderWidth: 3,
          pointRadius: 0
        }
      ]
    },
    options: {
      scales: {
        y: {
          ticks: { color: "#A0A8B8" },
          grid: { color: "rgba(255,255,255,0.05)" }
        },
        x: {
          ticks: { color: "#A0A8B8" },
          grid: { display: false }
        }
      },
      plugins: {
        legend: { display: false }
      }
    }
  });
}

// PROBABILITY SECTION
function renderProbability(allPaths, initialCapital) {
  const row = document.getElementById("probRow");
  row.innerHTML = "";

  const finals = allPaths.map((p) => (p.final / initialCapital - 1) * 100);

  const buckets = {
    loss: finals.filter((x) => x < 0).length,
    small: finals.filter((x) => x >= 0 && x < 20).length,
    med: finals.filter((x) => x >= 20 && x < 50).length,
    large: finals.filter((x) => x >= 50).length
  };

  function prob(label, val) {
    const pct = ((val / finals.length) * 100).toFixed(1) + "%";
    return `
      <div class="prob-card">
        <div class="prob-label">${label}</div>
        <div class="prob-value">${pct}</div>
      </div>
    `;
  }

  row.innerHTML =
    prob("Loss Outcome", buckets.loss) +
    prob("0–20% Gain", buckets.small) +
    prob("20–50% Gain", buckets.med) +
    prob("50%+ Gain", buckets.large);
}

// Bind run button
document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("runBtn");
  if (btn) btn.addEventListener("click", runSimulation);
});


