<script>
  // -----------------------------
  // CONFIG
  // -----------------------------
  const NUM_PATHS = 80; // number of Monte Carlo equity paths

  const runBtn       = document.getElementById("runBtn");
  const resultsGridEl = document.getElementById("resultsGrid");
  const probRowEl     = document.getElementById("probRow");
  const tabButtons    = document.querySelectorAll(".tab-btn");

  let equityChart = null;
  let currentScenario = "best"; // "best" | "median" | "worst"
  let lastSimResult = null;

  // -----------------------------
  // MAIN SIMULATION
  // -----------------------------
  function runSimulation() {
    // disable button while simulating
    runBtn.disabled = true;
    runBtn.textContent = "Running...";

    const winRateInput  = document.getElementById("winRate");
    const rrInput       = document.getElementById("rr");
    const riskPctInput  = document.getElementById("riskPct");
    const numTradesInput = document.getElementById("numTrades");
    const initialCapitalInput = document.getElementById("initialCapital");

    const winRate = parseFloat(winRateInput.value) / 100;
    const rr = parseFloat(rrInput.value);
    const riskPct = parseFloat(riskPctInput.value) / 100;
    const numTrades = parseInt(numTradesInput.value, 10);
    const initialCapital = parseFloat(initialCapitalInput.value);

    if (
      isNaN(winRate) || isNaN(rr) || isNaN(riskPct) ||
      isNaN(numTrades) || isNaN(initialCapital) ||
      winRate <= 0 || winRate >= 1 ||
      rr <= 0 || riskPct <= 0 || numTrades <= 0 || initialCapital <= 0
    ) {
      alert("Please enter valid positive numbers for all parameters.");
      runBtn.disabled = false;
      runBtn.textContent = "Run Simulation";
      return;
    }

    // Generate Monte Carlo paths
    const paths = [];
    for (let i = 0; i < NUM_PATHS; i++) {
      paths.push(simulateEquityPath({
        winRate, rr, riskPct, numTrades, initialCapital
      }));
    }

    // Sort by final balance to get scenarios
    const sorted = [...paths].sort((a, b) => a.finalBalance - b.finalBalance);
    const worst  = sorted[0];
    const best   = sorted[sorted.length - 1];
    const median = sorted[Math.floor(sorted.length / 2)];

    // Probability buckets (based on % return)
    const returnsPct = paths.map(p => (p.finalBalance / initialCapital - 1) * 100);
    const probLoss       = returnsPct.filter(r => r < 0).length / returnsPct.length * 100;
    const probSmallGain  = returnsPct.filter(r => r >= 0 && r < 30).length / returnsPct.length * 100;
    const probMediumGain = returnsPct.filter(r => r >= 30 && r < 60).length / returnsPct.length * 100;
    const probLargeGain  = returnsPct.filter(r => r >= 60).length / returnsPct.length * 100;

    // Expectancy in R
    const expectancyR = winRate * rr - (1 - winRate) * 1;

    lastSimResult = {
      winRate,
      rr,
      riskPct,
      numTrades,
      initialCapital,
      paths,
      scenarios: { best, median, worst },
      probs: { probLoss, probSmallGain, probMediumGain, probLargeGain },
      expectancyR
    };

    // Always reset to "best" after a new run
    currentScenario = "best";
    setActiveTabButton();

    renderResults(lastSimResult);
    renderProbabilities(lastSimResult);
    renderChart(lastSimResult);

    runBtn.disabled = false;
    runBtn.textContent = "Run Simulation";
  }

  // Simulate a single equity path
  function simulateEquityPath({ winRate, rr, riskPct, numTrades, initialCapital }) {
    let balance = initialCapital;
    let peak = initialCapital;
    let maxDD = 0;

    const curve = [initialCapital];
    const tradeResults = [];

    let winStreak = 0;
    let lossStreak = 0;
    let maxWinStreak = 0;
    let maxLossStreak = 0;

    for (let i = 0; i < numTrades; i++) {
      const isWin = Math.random() < winRate;
      const riskAmount = balance * riskPct;
      const rMultiple = isWin ? rr : -1;
      const profit = riskAmount * rMultiple;

      balance += profit;
      curve.push(balance);
      tradeResults.push(profit);

      // streaks
      if (isWin) {
        winStreak++;
        lossStreak = 0;
      } else {
        lossStreak++;
        winStreak = 0;
      }
      if (winStreak > maxWinStreak) maxWinStreak = winStreak;
      if (lossStreak > maxLossStreak) maxLossStreak = lossStreak;

      // drawdown
      if (balance > peak) {
        peak = balance;
      }
      const dd = (peak - balance) / peak;
      if (dd > maxDD) maxDD = dd;
    }

    return {
      curve,
      finalBalance: balance,
      maxDrawdown: maxDD,
      maxWinStreak,
      maxLossStreak
    };
  }

  // -----------------------------
  // RENDERING
  // -----------------------------
  function scenarioFromKey(result) {
    if (!result) return null;
    if (currentScenario === "median") return result.scenarios.median;
    if (currentScenario === "worst")  return result.scenarios.worst;
    return result.scenarios.best;
  }

  function labelForScenario(key) {
    if (key === "median") return "most probable";
    if (key === "worst")  return "worst-case";
    return "best-case";
  }

  function renderResults(result) {
    const scen = scenarioFromKey(result);
    if (!scen) return;

    const start = result.initialCapital;
    const end   = scen.finalBalance;
    const retPct = (end / start - 1) * 100;
    const retR   = (end - start) / (start * result.riskPct);
    const maxDDpct = scen.maxDrawdown * 100;

    resultsGridEl.innerHTML = `
      <div class="stat-card">
        <div class="stat-label">Start Balance</div>
        <div class="stat-value">$${start.toFixed(2)}</div>
        <div class="stat-note">Initial capital used in all simulations.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">End Balance</div>
        <div class="stat-value">$${end.toFixed(2)}</div>
        <div class="stat-note">Final balance for the ${labelForScenario(currentScenario)} path.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Return (Compounded)</div>
        <div class="stat-value">${retPct.toFixed(2)}%</div>
        <div class="stat-note">% change from start to finish.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Return (R)</div>
        <div class="stat-value">${retR.toFixed(1)}R</div>
        <div class="stat-note">Total R-multiples gained or lost versus initial risk size.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Expectancy</div>
        <div class="stat-value">${result.expectancyR >= 0 ? "+" : ""}${result.expectancyR.toFixed(2)}R</div>
        <div class="stat-note">Expected R per trade from your win rate and R:R.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Max Drawdown</div>
        <div class="stat-value">${maxDDpct.toFixed(2)}%</div>
        <div class="stat-note">Worst peak-to-trough decline in this scenario.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Max Consecutive Wins</div>
        <div class="stat-value">${scen.maxWinStreak}</div>
        <div class="stat-note">Longest winning streak on this equity curve.</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Max Consecutive Losses</div>
        <div class="stat-value">${scen.maxLossStreak}</div>
        <div class="stat-note">Longest losing streak on this equity curve.</div>
      </div>
    `;
  }

  function renderProbabilities(result) {
    const p = result.probs;
    probRowEl.innerHTML = `
      <div class="prob-card">
        <div class="prob-label">Probability of Loss</div>
        <div class="prob-value">${p.probLoss.toFixed(1)}%</div>
      </div>
      <div class="prob-card">
        <div class="prob-label">Probability of Small Gain (0–30%)</div>
        <div class="prob-value">${p.probSmallGain.toFixed(1)}%</div>
      </div>
      <div class="prob-card">
        <div class="prob-label">Probability of Medium Gain (30–60%)</div>
        <div class="prob-value">${p.probMediumGain.toFixed(1)}%</div>
      </div>
      <div class="prob-card">
        <div class="prob-label">Probability of Large Gain (60%+)</div>
        <div class="prob-value">${p.probLargeGain.toFixed(1)}%</div>
      </div>
    `;
  }

  function renderChart(result) {
    const ctx = document.getElementById("equityChart").getContext("2d");

    if (equityChart) {
      equityChart.destroy();
      equityChart = null;
    }

    const numTrades = result.numTrades;
    const labels = Array.from({ length: numTrades + 1 }, (_, i) => i);

    const baseDatasets = result.paths.map(p => ({
      data: p.curve,
      borderColor: "rgba(160,168,184,0.3)",
      borderWidth: 1,
      pointRadius: 0,
      fill: false,
      tension: 0.15
    }));

    const { best, median, worst } = result.scenarios;

    const highlightDatasets = [
      {
        label: "Best",
        data: best.curve,
        borderColor: "#2EC7FF",
        borderWidth: 3,
        pointRadius: 0,
        tension: 0.15
      },
      {
        label: "Most Probable",
        data: median.curve,
        borderColor: "#4ADE80",
        borderWidth: 3,
        pointRadius: 0,
        tension: 0.15
      },
      {
        label: "Worst",
        data: worst.curve,
        borderColor: "#F97373",
        borderWidth: 3,
        pointRadius: 0,
        tension: 0.15
      }
    ];

    equityChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [...baseDatasets, ...highlightDatasets]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: "index",
          intersect: false
        },
        plugins: {
          legend: { display: false }
        },
        scales: {
          x: {
            title: { display: true, text: "Trade Number" },
            grid: { color: "rgba(148,163,184,0.1)" },
            ticks: { color: "#A0A8B8" }
          },
          y: {
            title: { display: true, text: "Equity" },
            grid: { color: "rgba(148,163,184,0.1)" },
            ticks: { color: "#A0A8B8" }
          }
        }
      }
    });
  }

  // -----------------------------
  // TAB LOGIC
  // -----------------------------
  function setActiveTabButton() {
    tabButtons.forEach(btn => {
      const s = btn.dataset.scenario;
      btn.classList.toggle("active", s === currentScenario);
    });
  }

  tabButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const scenario = btn.dataset.scenario;
      if (!scenario) return;

      currentScenario = scenario;
      setActiveTabButton();

      if (lastSimResult) {
        renderResults(lastSimResult);
        renderChart(lastSimResult);
      }
    });
  });

  // -----------------------------
  // EVENT BINDINGS
  // -----------------------------
  runBtn.addEventListener("click", runSimulation);
</script>
